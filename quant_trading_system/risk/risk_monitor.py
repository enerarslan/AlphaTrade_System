"""
Real-time risk monitoring module.

Provides continuous monitoring of portfolio risk metrics:
- VaR (Value at Risk) - Historical, Parametric, Monte Carlo
- CVaR (Conditional VaR / Expected Shortfall)
- Drawdown metrics
- Position and market risk
- Greeks (for options)

Generates alerts when risk thresholds are breached.
"""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from datetime import datetime, timedelta, timezone
from decimal import Decimal
from enum import Enum
from typing import Any, Callable

import numpy as np
from scipy import stats

from quant_trading_system.core.data_types import Portfolio, Position, RiskMetrics
from quant_trading_system.core.events import Event, EventBus, EventType, create_risk_event
from quant_trading_system.core.exceptions import RiskError

logger = logging.getLogger(__name__)


class VaRMethod(str, Enum):
    """VaR calculation method."""

    HISTORICAL = "historical"
    PARAMETRIC = "parametric"
    MONTE_CARLO = "monte_carlo"


class AlertSeverity(str, Enum):
    """Alert severity levels."""

    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"


@dataclass
class RiskAlert:
    """Risk alert generated by monitor."""

    alert_id: str
    severity: AlertSeverity
    alert_type: str
    message: str
    metric_name: str
    current_value: float
    threshold_value: float
    symbol: str | None = None
    recommended_action: str | None = None
    timestamp: datetime = field(default_factory=datetime.utcnow)
    acknowledged: bool = False
    metadata: dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "alert_id": self.alert_id,
            "severity": self.severity.value,
            "alert_type": self.alert_type,
            "message": self.message,
            "metric_name": self.metric_name,
            "current_value": self.current_value,
            "threshold_value": self.threshold_value,
            "symbol": self.symbol,
            "recommended_action": self.recommended_action,
            "timestamp": self.timestamp.isoformat(),
            "acknowledged": self.acknowledged,
            "metadata": self.metadata,
        }


@dataclass
class DrawdownState:
    """Current drawdown state tracking."""

    peak_equity: Decimal
    current_equity: Decimal
    current_drawdown: float
    max_drawdown: float
    drawdown_start: datetime | None = None
    drawdown_duration_bars: int = 0
    last_peak_date: datetime = field(default_factory=datetime.utcnow)

    @property
    def is_in_drawdown(self) -> bool:
        """Check if currently in drawdown."""
        return self.current_drawdown > 0.001

    def update(self, new_equity: Decimal) -> None:
        """Update drawdown state with new equity value."""
        self.current_equity = new_equity

        if new_equity > self.peak_equity:
            self.peak_equity = new_equity
            self.last_peak_date = datetime.now(timezone.utc)
            self.drawdown_start = None
            self.drawdown_duration_bars = 0
            self.current_drawdown = 0.0
        else:
            self.current_drawdown = float(1 - new_equity / self.peak_equity)
            self.max_drawdown = max(self.max_drawdown, self.current_drawdown)
            if self.drawdown_start is None:
                self.drawdown_start = datetime.now(timezone.utc)
            self.drawdown_duration_bars += 1


class VaRCalculator:
    """Calculate Value at Risk using multiple methods."""

    def __init__(
        self,
        confidence_levels: list[float] | None = None,
        lookback_days: int = 252,
        num_simulations: int = 10000,
    ) -> None:
        """Initialize VaR calculator.

        Args:
            confidence_levels: Confidence levels (e.g., [0.95, 0.99]).
            lookback_days: Days of historical data to use.
            num_simulations: Number of Monte Carlo simulations.
        """
        self.confidence_levels = confidence_levels or [0.95, 0.99]
        self.lookback_days = lookback_days
        self.num_simulations = num_simulations

    def calculate_historical_var(
        self,
        returns: np.ndarray,
        portfolio_value: float,
        confidence: float = 0.95,
    ) -> float:
        """Calculate VaR using historical simulation.

        Args:
            returns: Historical portfolio returns.
            portfolio_value: Current portfolio value.
            confidence: Confidence level (e.g., 0.95).

        Returns:
            VaR amount (positive number representing loss).
        """
        if len(returns) == 0:
            return 0.0

        # Calculate percentile of losses
        var_pct = np.percentile(returns, (1 - confidence) * 100)
        return abs(var_pct * portfolio_value)

    def calculate_parametric_var(
        self,
        returns: np.ndarray,
        portfolio_value: float,
        confidence: float = 0.95,
    ) -> float:
        """Calculate VaR using parametric (normal) method.

        Args:
            returns: Historical portfolio returns.
            portfolio_value: Current portfolio value.
            confidence: Confidence level.

        Returns:
            VaR amount.
        """
        if len(returns) == 0:
            return 0.0

        mean = np.mean(returns)
        std = np.std(returns)

        if std == 0:
            return 0.0

        z_score = stats.norm.ppf(1 - confidence)
        var_pct = mean + z_score * std
        return abs(var_pct * portfolio_value)

    def calculate_monte_carlo_var(
        self,
        returns: np.ndarray,
        portfolio_value: float,
        confidence: float = 0.95,
        days: int = 1,
    ) -> float:
        """Calculate VaR using Monte Carlo simulation.

        Args:
            returns: Historical portfolio returns.
            portfolio_value: Current portfolio value.
            confidence: Confidence level.
            days: Time horizon in days.

        Returns:
            VaR amount.
        """
        if len(returns) == 0:
            return 0.0

        mean = np.mean(returns)
        std = np.std(returns)

        if std == 0:
            return 0.0

        # Generate random scenarios
        simulated_returns = np.random.normal(
            mean * days, std * np.sqrt(days), self.num_simulations
        )

        # Calculate VaR from simulated distribution
        var_pct = np.percentile(simulated_returns, (1 - confidence) * 100)
        return abs(var_pct * portfolio_value)

    def calculate_cvar(
        self,
        returns: np.ndarray,
        portfolio_value: float,
        confidence: float = 0.95,
    ) -> float:
        """Calculate Conditional VaR (Expected Shortfall).

        Args:
            returns: Historical portfolio returns.
            portfolio_value: Current portfolio value.
            confidence: Confidence level.

        Returns:
            CVaR amount.
        """
        if len(returns) == 0:
            return 0.0

        var_threshold = np.percentile(returns, (1 - confidence) * 100)
        tail_losses = returns[returns <= var_threshold]

        if len(tail_losses) == 0:
            return self.calculate_historical_var(returns, portfolio_value, confidence)

        cvar_pct = np.mean(tail_losses)
        return abs(cvar_pct * portfolio_value)


class RiskMonitor:
    """Real-time risk monitoring and alert generation."""

    def __init__(
        self,
        event_bus: EventBus | None = None,
        var_calculator: VaRCalculator | None = None,
        alert_callback: Callable[[RiskAlert], None] | None = None,
    ) -> None:
        """Initialize risk monitor.

        Args:
            event_bus: Event bus for publishing risk events.
            var_calculator: VaR calculator instance.
            alert_callback: Callback function for alerts.
        """
        self.event_bus = event_bus
        self.var_calculator = var_calculator or VaRCalculator()
        self.alert_callback = alert_callback

        # State tracking
        self._drawdown_state: DrawdownState | None = None
        self._returns_history: list[float] = []
        self._alerts: list[RiskAlert] = []
        self._alert_counter = 0

        # Default thresholds
        self._thresholds: dict[str, tuple[float, AlertSeverity]] = {
            "var_95_pct": (0.02, AlertSeverity.WARNING),  # 2% of equity
            "var_99_pct": (0.03, AlertSeverity.CRITICAL),
            "cvar_pct": (0.04, AlertSeverity.CRITICAL),
            "current_drawdown": (0.05, AlertSeverity.WARNING),
            "max_drawdown": (0.10, AlertSeverity.CRITICAL),
            "volatility_annual": (0.30, AlertSeverity.WARNING),
            "position_concentration": (0.15, AlertSeverity.WARNING),
            "sector_concentration": (0.30, AlertSeverity.WARNING),
        }

    def set_threshold(
        self,
        metric: str,
        value: float,
        severity: AlertSeverity = AlertSeverity.WARNING,
    ) -> None:
        """Set alert threshold for a metric.

        Args:
            metric: Metric name.
            value: Threshold value.
            severity: Alert severity when breached.
        """
        self._thresholds[metric] = (value, severity)

    def initialize(self, initial_equity: Decimal) -> None:
        """Initialize monitor with starting equity.

        Args:
            initial_equity: Starting portfolio equity.
        """
        self._drawdown_state = DrawdownState(
            peak_equity=initial_equity,
            current_equity=initial_equity,
            current_drawdown=0.0,
            max_drawdown=0.0,
        )

    def update(
        self,
        portfolio: Portfolio,
        returns: np.ndarray | None = None,
        prices: dict[str, Decimal] | None = None,
    ) -> RiskMetrics:
        """Update risk metrics with new portfolio state.

        Args:
            portfolio: Current portfolio state.
            returns: Historical returns for VaR calculation.
            prices: Current market prices.

        Returns:
            Updated risk metrics.
        """
        # Update drawdown tracking
        if self._drawdown_state is None:
            self.initialize(portfolio.equity)
        else:
            self._drawdown_state.update(portfolio.equity)

        # Calculate VaR metrics
        portfolio_value = float(portfolio.equity)
        returns_array = returns if returns is not None else np.array(self._returns_history)

        var_95 = Decimal("0")
        var_99 = Decimal("0")
        cvar = Decimal("0")

        if len(returns_array) > 0:
            var_95 = Decimal(str(self.var_calculator.calculate_historical_var(
                returns_array, portfolio_value, 0.95
            )))
            var_99 = Decimal(str(self.var_calculator.calculate_historical_var(
                returns_array, portfolio_value, 0.99
            )))
            cvar = Decimal(str(self.var_calculator.calculate_cvar(
                returns_array, portfolio_value, 0.95
            )))

        # Calculate volatility
        volatility = 0.0
        if len(returns_array) > 1:
            volatility = float(np.std(returns_array) * np.sqrt(252))

        # Calculate position metrics
        sector_exposures = self._calculate_sector_exposures(portfolio)

        # Build risk metrics
        metrics = RiskMetrics(
            portfolio_var_95=var_95,
            portfolio_var_99=var_99,
            portfolio_cvar=cvar,
            current_drawdown=self._drawdown_state.current_drawdown if self._drawdown_state else 0.0,
            max_drawdown=self._drawdown_state.max_drawdown if self._drawdown_state else 0.0,
            volatility_annual=volatility,
            sector_exposures=sector_exposures,
        )

        # Check for breaches and generate alerts
        self._check_thresholds(metrics, portfolio)

        return metrics

    def _calculate_sector_exposures(self, portfolio: Portfolio) -> dict[str, Decimal]:
        """Calculate sector exposures from portfolio positions."""
        # This is a placeholder - in production, we'd lookup sector from symbol
        exposures: dict[str, Decimal] = {}
        if portfolio.equity > 0:
            for symbol, position in portfolio.positions.items():
                # Placeholder: assign all to "UNKNOWN" sector
                sector = "UNKNOWN"
                if sector not in exposures:
                    exposures[sector] = Decimal("0")
                exposures[sector] += abs(position.market_value) / portfolio.equity
        return exposures

    def _check_thresholds(self, metrics: RiskMetrics, portfolio: Portfolio) -> None:
        """Check metrics against thresholds and generate alerts."""
        checks = [
            ("var_95_pct", float(metrics.portfolio_var_95 / portfolio.equity) if portfolio.equity > 0 else 0),
            ("var_99_pct", float(metrics.portfolio_var_99 / portfolio.equity) if portfolio.equity > 0 else 0),
            ("cvar_pct", float(metrics.portfolio_cvar / portfolio.equity) if portfolio.equity > 0 else 0),
            ("current_drawdown", metrics.current_drawdown),
            ("max_drawdown", metrics.max_drawdown),
            ("volatility_annual", metrics.volatility_annual),
        ]

        # Check position concentration
        if portfolio.equity > 0:
            for symbol, position in portfolio.positions.items():
                concentration = float(abs(position.market_value) / portfolio.equity)
                threshold, severity = self._thresholds.get("position_concentration", (0.15, AlertSeverity.WARNING))
                if concentration > threshold:
                    self._generate_alert(
                        alert_type="position_concentration",
                        metric_name="position_concentration",
                        current_value=concentration,
                        threshold_value=threshold,
                        severity=severity,
                        symbol=symbol,
                        message=f"Position concentration for {symbol} ({concentration:.1%}) exceeds limit ({threshold:.1%})",
                    )

        # Check portfolio-level thresholds
        for metric_name, current_value in checks:
            if metric_name not in self._thresholds:
                continue

            threshold, severity = self._thresholds[metric_name]
            if current_value > threshold:
                self._generate_alert(
                    alert_type="threshold_breach",
                    metric_name=metric_name,
                    current_value=current_value,
                    threshold_value=threshold,
                    severity=severity,
                    message=f"{metric_name} ({current_value:.2%}) exceeds limit ({threshold:.2%})",
                )

    def _generate_alert(
        self,
        alert_type: str,
        metric_name: str,
        current_value: float,
        threshold_value: float,
        severity: AlertSeverity,
        message: str,
        symbol: str | None = None,
    ) -> RiskAlert:
        """Generate and dispatch a risk alert."""
        self._alert_counter += 1
        alert = RiskAlert(
            alert_id=f"ALERT-{self._alert_counter:06d}",
            severity=severity,
            alert_type=alert_type,
            message=message,
            metric_name=metric_name,
            current_value=current_value,
            threshold_value=threshold_value,
            symbol=symbol,
            recommended_action=self._get_recommended_action(metric_name, severity),
        )

        self._alerts.append(alert)

        # Invoke callback
        if self.alert_callback:
            self.alert_callback(alert)

        # Publish event
        if self.event_bus:
            event_type = (
                EventType.KILL_SWITCH_TRIGGERED if severity == AlertSeverity.CRITICAL
                else EventType.EXPOSURE_WARNING if "exposure" in metric_name or "concentration" in metric_name
                else EventType.DRAWDOWN_WARNING if "drawdown" in metric_name
                else EventType.LIMIT_BREACH
            )
            event = create_risk_event(
                event_type=event_type,
                risk_data=alert.to_dict(),
                source="RiskMonitor",
            )
            self.event_bus.publish(event)

        logger.warning(f"Risk alert generated: {alert.message}")
        return alert

    def _get_recommended_action(self, metric_name: str, severity: AlertSeverity) -> str:
        """Get recommended action based on metric and severity."""
        actions = {
            ("var_95_pct", AlertSeverity.WARNING): "Consider reducing position sizes",
            ("var_99_pct", AlertSeverity.CRITICAL): "Reduce exposure immediately",
            ("current_drawdown", AlertSeverity.WARNING): "Monitor closely, prepare risk reduction",
            ("max_drawdown", AlertSeverity.CRITICAL): "Halt new positions, consider deleveraging",
            ("volatility_annual", AlertSeverity.WARNING): "Reduce position sizes per volatility",
            ("position_concentration", AlertSeverity.WARNING): "Diversify position",
        }
        return actions.get((metric_name, severity), "Review and take appropriate action")

    def get_active_alerts(
        self,
        severity: AlertSeverity | None = None,
        since: datetime | None = None,
    ) -> list[RiskAlert]:
        """Get active (unacknowledged) alerts.

        Args:
            severity: Filter by severity level.
            since: Filter alerts after this time.

        Returns:
            List of active alerts.
        """
        alerts = [a for a in self._alerts if not a.acknowledged]
        if severity:
            alerts = [a for a in alerts if a.severity == severity]
        if since:
            alerts = [a for a in alerts if a.timestamp >= since]
        return alerts

    def acknowledge_alert(self, alert_id: str) -> bool:
        """Acknowledge an alert.

        Args:
            alert_id: ID of alert to acknowledge.

        Returns:
            True if alert was found and acknowledged.
        """
        for alert in self._alerts:
            if alert.alert_id == alert_id:
                alert.acknowledged = True
                return True
        return False

    def get_drawdown_state(self) -> DrawdownState | None:
        """Get current drawdown state."""
        return self._drawdown_state

    def add_return(self, daily_return: float) -> None:
        """Add a daily return to history.

        Args:
            daily_return: Daily portfolio return.
        """
        self._returns_history.append(daily_return)
        # Keep only lookback period
        max_history = self.var_calculator.lookback_days
        if len(self._returns_history) > max_history:
            self._returns_history = self._returns_history[-max_history:]

    def get_risk_summary(self, portfolio: Portfolio) -> dict[str, Any]:
        """Get a summary of current risk state.

        Args:
            portfolio: Current portfolio.

        Returns:
            Dictionary with risk summary.
        """
        returns_array = np.array(self._returns_history) if self._returns_history else np.array([])
        metrics = self.update(portfolio, returns_array)

        return {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "portfolio_value": float(portfolio.equity),
            "var_95": float(metrics.portfolio_var_95),
            "var_99": float(metrics.portfolio_var_99),
            "cvar": float(metrics.portfolio_cvar),
            "current_drawdown": metrics.current_drawdown,
            "max_drawdown": metrics.max_drawdown,
            "volatility_annual": metrics.volatility_annual,
            "active_alerts": len(self.get_active_alerts()),
            "critical_alerts": len(self.get_active_alerts(AlertSeverity.CRITICAL)),
            "position_count": portfolio.position_count,
            "gross_exposure": float(portfolio.gross_exposure),
            "net_exposure": float(portfolio.net_exposure),
        }


class PositionRiskAnalyzer:
    """Analyze risk at the position level."""

    def __init__(self) -> None:
        """Initialize position risk analyzer."""
        self._position_returns: dict[str, list[float]] = {}

    def update_position_return(self, symbol: str, daily_return: float) -> None:
        """Update return history for a position.

        Args:
            symbol: Position symbol.
            daily_return: Daily return for the position.
        """
        if symbol not in self._position_returns:
            self._position_returns[symbol] = []
        self._position_returns[symbol].append(daily_return)
        # Keep 252 days
        if len(self._position_returns[symbol]) > 252:
            self._position_returns[symbol] = self._position_returns[symbol][-252:]

    def analyze_position(
        self,
        position: Position,
        portfolio: Portfolio,
    ) -> dict[str, Any]:
        """Analyze risk for a single position.

        Args:
            position: Position to analyze.
            portfolio: Current portfolio.

        Returns:
            Dictionary with position risk metrics.
        """
        symbol = position.symbol
        returns = np.array(self._position_returns.get(symbol, []))

        # Calculate position-level metrics
        volatility = float(np.std(returns) * np.sqrt(252)) if len(returns) > 1 else 0.0
        concentration = float(abs(position.market_value) / portfolio.equity) if portfolio.equity > 0 else 0.0

        # Calculate beta (simplified - against portfolio)
        portfolio_returns = np.array(self._position_returns.get("PORTFOLIO", []))
        beta = 1.0
        if len(returns) > 1 and len(portfolio_returns) > 1:
            min_len = min(len(returns), len(portfolio_returns))
            cov = np.cov(returns[-min_len:], portfolio_returns[-min_len:])
            if cov[1, 1] > 0:
                beta = cov[0, 1] / cov[1, 1]

        return {
            "symbol": symbol,
            "market_value": float(position.market_value),
            "unrealized_pnl": float(position.unrealized_pnl),
            "unrealized_pnl_pct": position.unrealized_pnl_pct,
            "concentration": concentration,
            "volatility": volatility,
            "beta": beta,
            "is_long": position.is_long,
            "return_history_days": len(returns),
        }

    def calculate_correlation_matrix(self, symbols: list[str]) -> np.ndarray:
        """Calculate correlation matrix for positions.

        Args:
            symbols: List of position symbols.

        Returns:
            Correlation matrix.
        """
        n = len(symbols)
        corr_matrix = np.eye(n)

        for i in range(n):
            for j in range(i + 1, n):
                returns_i = np.array(self._position_returns.get(symbols[i], []))
                returns_j = np.array(self._position_returns.get(symbols[j], []))

                if len(returns_i) > 1 and len(returns_j) > 1:
                    min_len = min(len(returns_i), len(returns_j))
                    corr = np.corrcoef(returns_i[-min_len:], returns_j[-min_len:])[0, 1]
                    if not np.isnan(corr):
                        corr_matrix[i, j] = corr
                        corr_matrix[j, i] = corr

        return corr_matrix
